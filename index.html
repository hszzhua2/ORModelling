<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIM è‡ªåŠ¨åŒ–é€»è¾‘æ¼”ç¤º</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.1/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.1/examples/js/controls/OrbitControls.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#38b2ac',
                        secondary: '#4299e1',
                        accent: '#ecc94b',
                        warning: '#ed8936',
                        danger: '#f56565',
                        dark: '#1a202c',
                        'gray-dark': '#2d3748',
                        'gray-medium': '#4a5568',
                        'gray-light': '#a0aec0'
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .backdrop-blur-sm {
                backdrop-filter: blur(4px);
            }
            .pointer-events-none {
                pointer-events: none;
            }
            .pointer-events-auto {
                pointer-events: auto;
            }
            .tracking-wider {
                letter-spacing: 0.05em;
            }
            .tracking-widest {
                letter-spacing: 0.1em;
            }
            .uppercase {
                text-transform: uppercase;
            }
            .whitespace-nowrap {
                white-space: nowrap;
            }
            .font-sans {
                font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            }
        }
    </style>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            /* ç¦æ­¢é€‰å–æ–‡æœ¬ï¼Œæå‡æ‹–æ‹½ä½“éªŒ */
            user-select: none; 
        }
        .html-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(4px);
            pointer-events: none;
            text-align: center;
            white-space: nowrap;
            top: 0;
            left: 0;
            z-index: 5;
            display: none; 
        }
        .html-label .label-title {
            font-weight: bold;
        }
        .html-label .label-area {
            font-size: 10px;
            opacity: 0.8;
        }
        /* æ·»åŠ æ“ä½œæç¤ºæ ·å¼ */
        .controls-hint {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.5);
            padding: 0.5rem;
            border-radius: 0.5rem;
            color: #a0aec0;
            font-size: 0.75rem;
            pointer-events: none;
            z-index: 20;
            border: 1px solid rgba(255,255,255,0.1);
        }
    </style>
</head>
<body class="w-full h-screen bg-gray-900 flex flex-col relative overflow-hidden font-sans">
    <!-- é¡¶éƒ¨æ ‡é¢˜æ  -->
    <div class="absolute top-0 left-0 w-full p-4 z-10 flex justify-between items-start pointer-events-none">
        <div>
            <h1 class="text-2xl text-white font-bold tracking-wider">BIM è‡ªåŠ¨åŒ–é€»è¾‘æ¼”ç¤º</h1>
            <p class="text-gray-400 text-sm mt-1">
                <span class="text-blue-400 font-bold">å¢™ä½“(è¾“å…¥)</span> vs <span class="text-green-400 font-bold">æˆ¿é—´(è®¡ç®—ç»“æœ)</span>
            </p>
        </div>
        
        <div class="bg-gray-800/80 p-4 rounded-lg backdrop-blur border border-gray-700 pointer-events-auto shadow-xl">
            <h3 class="text-white text-sm font-bold mb-2 border-b border-gray-600 pb-2">è‡ªåŠ¨åŒ–è§„åˆ™å¼•æ“</h3>
            <div class="space-y-2 text-xs">
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-[#38b2ac]"></div>
                    <span class="text-gray-300">æ‰‹æœ¯å®¤ (å¤§é¢ç§¯ + æ–¹æ­£)</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-[#4299e1]"></div>
                    <span class="text-gray-300">åˆ·æ‰‹/å‡†å¤‡é—´ (å°é¢ç§¯)</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-[#ecc94b]"></div>
                    <span class="text-gray-300">èµ°å»Š (é•¿å®½æ¯” &gt; 3:1)</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-3 bg-[#ed8936]"></div>
                    <span class="text-gray-300">åº“æˆ¿/è¾…æˆ¿ (å…¶ä»–)</span>
                </div>
            </div>
        </div>
    </div>

    <!-- æ“ä½œæç¤º -->
    <div class="controls-hint">
        <div>ğŸ–±ï¸ å·¦é”®ï¼šç»˜åˆ¶/åˆ é™¤</div>
        <div>ğŸ–±ï¸ å³é”®ï¼šæ—‹è½¬è§†è§’</div>
        <div>ğŸ–±ï¸ ä¸­é”®ï¼šå¹³ç§»è§†è§’</div>
    </div>

    <!-- åº•éƒ¨æ§åˆ¶æ  -->
    <div class="absolute bottom-6 left-1/2 transform -translate-x-1/2 z-10 flex gap-4 pointer-events-auto">
        <div class="bg-gray-800 rounded-full px-6 py-2 flex items-center gap-4 shadow-lg border border-gray-700">
            <span class="text-gray-400 text-xs uppercase tracking-widest mr-2">Drawing Tool</span>
            <button 
                id="drawModeBtn"
                class="px-4 py-1.5 rounded-full text-sm font-medium bg-blue-600 text-white transition-colors hover:bg-blue-500"
            >
                ç»˜åˆ¶å¢™ä½“ (Draw)
            </button>
            <div class="w-px h-6 bg-gray-600"></div>
            <button 
                id="clearBtn"
                class="px-4 py-1.5 rounded-full text-sm font-medium text-red-400 hover:bg-red-900/30 transition-colors"
            >
                æ¸…ç©ºå›¾çº¸
            </button>
        </div>
    </div>
    
    <!-- æç¤ºæ¡ -->
    <div class="absolute bottom-24 w-full text-center z-0 pointer-events-none">
        <p class="text-white/50 text-sm bg-black/30 inline-block px-4 py-1 rounded-full backdrop-blur-sm">
            ğŸ’¡ å°è¯•æŠŠä¸€ä¸ªå¤§çš„æ‰‹æœ¯å®¤ç”¨å¢™åˆ‡å¼€ï¼Œè§‚å¯ŸåŠŸèƒ½æ ‡ç­¾çš„è‡ªåŠ¨å˜åŒ–
        </p>
    </div>

    <!-- 3Dåœºæ™¯å®¹å™¨ -->
    <div id="scene-container" class="w-full h-full block"></div>

    <script>
        // --- ç±»å‹å®šä¹‰ ---
        // Point: [x, z] Grid coordinates
        // RoomType: 'OR' | 'SCRUB' | 'CORRIDOR' | 'STORAGE' | 'UNKNOWN' | 'OPEN'

        // --- å¸¸é‡é…ç½® ---
        const GRID_SIZE = 20; // 20x20 ç½‘æ ¼
        const CELL_SIZE = 1.5; // æ¯ä¸ªå•å…ƒæ ¼çš„ä¸–ç•Œå•ä½å¤§å°
        const WALL_HEIGHT = 2.5;
        const WALL_THICKNESS = 0.2;

        // é¢œè‰²å®šä¹‰
        const COLORS = {
            WALL: '#4a5568',
            WALL_PREVIEW: '#a0aec0',
            GRID: '#e2e8f0',
            OR: '#38b2ac',      // æ‰‹æœ¯å®¤ - é’è‰²
            SCRUB: '#4299e1',   // æ´—æ‰‹é—´ - è“è‰²
            CORRIDOR: '#ecc94b',// èµ°å»Š - é»„è‰²
            STORAGE: '#ed8936', // åº“æˆ¿ - æ©™è‰²
            UNKNOWN: '#cbd5e0', // æœªçŸ¥ - ç°è‰²
            HIGHLIGHT: '#f56565'
        };

        // --- æ ¸å¿ƒç®—æ³•ï¼šæˆ¿é—´è¯†åˆ«ä¸é€»è¾‘æ¨ç† ---
        const analyzeRooms = (walls) => {
            // 1. åˆå§‹åŒ–ç½‘æ ¼åœ°å›¾ (0 = ç©º, 1 = å¢™)
            const gridMap = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));

            // 2. å°†å¢™ä½“æ …æ ¼åŒ–åˆ°åœ°å›¾ä¸Š
            walls.forEach(wall => {
                const [x1, z1] = wall.start;
                const [x2, z2] = wall.end;
                
                // ç®€å•çš„ç›´çº¿æ …æ ¼åŒ–
                const dx = Math.abs(x2 - x1);
                const dz = Math.abs(z2 - z1);
                const sx = (x1 < x2) ? 1 : -1;
                const sz = (z1 < z2) ? 1 : -1;
                let err = dx - dz;
                let cx = x1;
                let cz = z1;

                while (true) {
                    if (cx >= 0 && cx < GRID_SIZE && cz >= 0 && cz < GRID_SIZE) {
                        gridMap[cx][cz] = 1; // æ ‡è®°ä¸ºå¢™
                    }
                    if (cx === x2 && cz === z2) break;
                    const e2 = 2 * err;
                    if (e2 > -dz) { err -= dz; cx += sx; }
                    if (e2 < dx) { err += dx; cz += sz; }
                }
            });

            // 3. æ³›æ´ªç®—æ³• (Flood Fill) å¯»æ‰¾è¿é€šåŒºåŸŸ
            const visited = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(false));
            const rooms = [];
            let roomIdCounter = 0;

            for (let x = 0; x < GRID_SIZE; x++) {
                for (let z = 0; z < GRID_SIZE; z++) {
                    if (gridMap[x][z] === 0 && !visited[x][z]) {
                        // å‘ç°æ–°åŒºåŸŸï¼Œå¼€å§‹æ‰©æ•£
                        const currentRoomCells = [];
                        const queue = [[x, z]];
                        visited[x][z] = true;
                        let isClosed = true; // å‡è®¾æ˜¯é—­åˆçš„

                        while (queue.length > 0) {
                            const [cx, cz] = queue.shift();
                            currentRoomCells.push([cx, cz]);

                            // æ£€æŸ¥æ˜¯å¦è§¦ç¢°åˆ°è¾¹ç•Œï¼ˆè§¦ç¢°è¾¹ç•Œæ„å‘³ç€ä¸æ˜¯å°é—­æˆ¿é—´ï¼‰
                            if (cx === 0 || cx === GRID_SIZE - 1 || cz === 0 || cz === GRID_SIZE - 1) {
                                isClosed = false;
                            }

                            // æ£€æŸ¥å››ä¸ªæ–¹å‘
                            const neighbors = [
                                [cx + 1, cz], [cx - 1, cz], [cx, cz + 1], [cx, cz - 1]
                            ];

                            for (const [nx, nz] of neighbors) {
                                if (nx >= 0 && nx < GRID_SIZE && nz >= 0 && nz < GRID_SIZE) {
                                    if (gridMap[nx][nz] === 0 && !visited[nx][nz]) {
                                        visited[nx][nz] = true;
                                        queue.push([nx, nz]);
                                    }
                                }
                            }
                        }

                        // 4. åªæœ‰å®Œå…¨é—­åˆçš„åŒºåŸŸæ‰ç®—ä½œ"æˆ¿é—´"
                        if (isClosed && currentRoomCells.length > 0) {
                            rooms.push(classifyRoom(currentRoomCells, roomIdCounter++));
                        }
                    }
                }
            }
            return rooms;
        };

        // --- è§„åˆ™å¼•æ“ï¼šæ ¹æ®å‡ ä½•å±æ€§å®šä¹‰åŠŸèƒ½ ---
        const classifyRoom = (cells, id) => {
            const area = cells.length; // é¢ç§¯è¿‘ä¼¼å€¼
            
            // è®¡ç®—åŒ…å›´ç›’ä»¥ç¡®å®šé•¿å®½æ¯”
            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            let sumX = 0, sumZ = 0;
            
            cells.forEach(([x, z]) => {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minZ = Math.min(minZ, z);
                maxZ = Math.max(maxZ, z);
                sumX += x;
                sumZ += z;
            });

            const width = maxX - minX + 1;
            const depth = maxZ - minZ + 1;
            const aspectRatio = Math.max(width, depth) / Math.min(width, depth);
            
            // ä¸–ç•Œåæ ‡ä¸­å¿ƒ
            const centerX = (sumX / area) * CELL_SIZE - (GRID_SIZE * CELL_SIZE) / 2 + CELL_SIZE/2;
            const centerZ = (sumZ / area) * CELL_SIZE - (GRID_SIZE * CELL_SIZE) / 2 + CELL_SIZE/2;

            // --- è‡ªåŠ¨åŒ–è§„åˆ™åˆ¤å®šé€»è¾‘ ---
            let type = 'UNKNOWN';
            let label = 'æœªå®šä¹‰';
            let color = COLORS.UNKNOWN;

            // è§„åˆ™ 1: æ‰‹æœ¯å®¤ (é¢ç§¯å¤§ä¸”æ¥è¿‘æ­£æ–¹å½¢)
            if (area >= 16 && aspectRatio < 2.0) {
                type = 'OR';
                label = `æ‰‹æœ¯å®¤ ${id+1}`;
                color = COLORS.OR;
            } 
            // è§„åˆ™ 2: èµ°å»Š (ç»†é•¿æ¡)
            else if (aspectRatio > 3.0 || (area > 20 && aspectRatio > 2.5)) {
                type = 'CORRIDOR';
                label = 'æ´å‡€èµ°å»Š';
                color = COLORS.CORRIDOR;
            }
            // è§„åˆ™ 3: æ´—æ‰‹/éº»é†‰å‡†å¤‡ (é¢ç§¯å°ï¼Œé€šå¸¸é™„å±äºæ‰‹æœ¯å®¤)
            else if (area < 9) {
                type = 'SCRUB';
                label = 'åˆ·æ‰‹é—´';
                color = COLORS.SCRUB;
            }
            // è§„åˆ™ 4: è¾…æˆ¿/åº“æˆ¿ (ä¸­ç­‰é¢ç§¯)
            else {
                type = 'STORAGE';
                label = 'æ— èŒåº“æˆ¿';
                color = COLORS.STORAGE;
            }

            return {
                id,
                cells,
                area,
                center: [centerX, 0.1, centerZ], // ç¨å¾®æŠ¬é«˜é¿å…Z-fighting
                type,
                label,
                color
            };
        };

        // --- 3Dåœºæ™¯ç®¡ç† ---
        class BIMScene {
            constructor(container) {
                this.container = container;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.raycaster = null;
                this.mouse = null;
                
                // åœºæ™¯å¯¹è±¡
                this.walls = [];
                this.rooms = [];
                this.wallMeshes = [];
                this.roomMeshes = [];
                this.labelDivs = [];
                this.gridHelper = null;
                this.interactionPlane = null;
                this.hoverMesh = null;
                this.previewWall = null;
                
                // äº¤äº’çŠ¶æ€
                this.isDrawing = false;
                this.startPoint = null;
                this.currentPoint = null;
                this.mode = 'DRAW'; // 'DRAW' | 'DELETE'
                
                this.init();
                this.setupEventListeners();
                this.animate();
            }

            init() {
                // åˆ›å»ºåœºæ™¯
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color('#1a202c');

                // åˆ›å»ºç›¸æœº
                this.camera = new THREE.PerspectiveCamera(
                    45,
                    this.container.clientWidth / this.container.clientHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(10, 20, 20);

                // åˆ›å»ºæ¸²æŸ“å™¨
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.container.appendChild(this.renderer.domElement);

                // åˆ›å»ºæ§åˆ¶å™¨
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.minPolarAngle = 0;
                this.controls.maxPolarAngle = Math.PI / 2.5;
                this.controls.maxDistance = 50;
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                
                // --- ä¼˜åŒ–æ“ä½œé€»è¾‘ ---
                // å·¦é”®ï¼šç¦ç”¨ç›¸æœºæ“ä½œï¼ˆç•™ç»™ç”»å¢™ï¼‰
                // ä¸­é”®ï¼šå¹³ç§» (Pan)
                // å³é”®ï¼šæ—‹è½¬ (Rotate)
                this.controls.mouseButtons = {
                    LEFT: null, 
                    MIDDLE: THREE.MOUSE.PAN,
                    RIGHT: THREE.MOUSE.ROTATE
                };

                // åˆ›å»ºå°„çº¿æ£€æµ‹å™¨
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                // æ·»åŠ ç¯å…‰
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(10, 20, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 1024;
                directionalLight.shadow.mapSize.height = 1024;
                this.scene.add(directionalLight);

                // åˆ›å»ºäº¤äº’å¹³é¢
                this.createInteractionPlane();

                // åˆ›å»ºç½‘æ ¼è¾…åŠ©çº¿
                this.createGridHelper();

                // åˆ›å»ºæ‚¬åœé«˜äº®ç½‘æ ¼
                this.createHoverMesh();

                // åˆå§‹åŒ–é¢„è®¾åœºæ™¯
                this.initPresetScene();

                // å¤„ç†çª—å£å¤§å°å˜åŒ–
                window.addEventListener('resize', () => this.onWindowResize());
            }

            createInteractionPlane() {
                const geometry = new THREE.PlaneGeometry(GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);
                const material = new THREE.MeshBasicMaterial({ visible: false });
                this.interactionPlane = new THREE.Mesh(geometry, material);
                this.interactionPlane.rotation.x = -Math.PI / 2;
                this.interactionPlane.position.y = 0.01;
                this.scene.add(this.interactionPlane);
            }

            createGridHelper() {
                this.gridHelper = new THREE.GridHelper(
                    GRID_SIZE * CELL_SIZE,
                    GRID_SIZE,
                    COLORS.GRID,
                    COLORS.GRID
                );
                this.gridHelper.position.y = 0.01;
                this.scene.add(this.gridHelper);
            }

            createHoverMesh() {
                const geometry = new THREE.PlaneGeometry(CELL_SIZE, CELL_SIZE);
                const material = new THREE.MeshBasicMaterial({
                    color: COLORS.HIGHLIGHT,
                    opacity: 0.3,
                    transparent: true
                });
                this.hoverMesh = new THREE.Mesh(geometry, material);
                this.hoverMesh.rotation.x = -Math.PI / 2;
                this.hoverMesh.visible = false;
                this.scene.add(this.hoverMesh);
            }

            initPresetScene() {
                const initialWalls = [
                    // å¤–æ¡†
                    { id: '1', start: [2, 2], end: [2, 12] },
                    { id: '2', start: [2, 12], end: [15, 12] },
                    { id: '3', start: [15, 12], end: [15, 2] },
                    { id: '4', start: [15, 2], end: [2, 2] },
                    // å†…éƒ¨èµ°å»Š
                    { id: '5', start: [6, 2], end: [6, 12] },
                    // ä¸€ä¸ªæœªå°é—­çš„ç¼ºå£...
                ];
                this.walls = initialWalls;
                this.updateScene();
            }

            setupEventListeners() {
                // ç¦ç”¨é»˜è®¤å³é”®èœå•ï¼Œä»¥ä¾¿ç”¨äºæ—‹è½¬è§†è§’
                this.container.addEventListener('contextmenu', (e) => e.preventDefault());

                // é¼ æ ‡äº‹ä»¶
                this.container.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.container.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.container.addEventListener('mouseup', () => this.onMouseUp());

                // è§¦æ‘¸äº‹ä»¶ (è§¦æ‘¸æ“ä½œæ¯”è¾ƒå¤æ‚ï¼Œè¿™é‡Œæš‚æ—¶ä¿æŒåŸºæœ¬å…¼å®¹ï¼Œä½†æ¨èä½¿ç”¨é¼ æ ‡)
                this.container.addEventListener('touchstart', (e) => this.onTouchStart(e));
                this.container.addEventListener('touchmove', (e) => this.onTouchMove(e));
                this.container.addEventListener('touchend', () => this.onTouchEnd());

                // æŒ‰é’®äº‹ä»¶
                document.getElementById('drawModeBtn').addEventListener('click', () => {
                    this.mode = this.mode === 'DRAW' ? 'DELETE' : 'DRAW';
                    this.updateDrawModeButton();
                });

                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.clearAll();
                });
            }

            updateDrawModeButton() {
                const btn = document.getElementById('drawModeBtn');
                if (this.mode === 'DRAW') {
                    btn.textContent = 'ç»˜åˆ¶å¢™ä½“ (Draw)';
                    btn.classList.remove('bg-red-600');
                    btn.classList.add('bg-blue-600');
                    btn.classList.remove('hover:bg-red-500');
                    btn.classList.add('hover:bg-blue-500');
                } else {
                    btn.textContent = 'åˆ é™¤å¢™ä½“ (Delete)';
                    btn.classList.remove('bg-blue-600');
                    btn.classList.add('bg-red-600');
                    btn.classList.remove('hover:bg-blue-500');
                    btn.classList.add('hover:bg-red-500');
                }
            }

            clearAll() {
                this.walls = [];
                this.updateScene();
            }

            onWindowResize() {
                this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
            }

            getMousePosition(event) {
                const rect = this.container.getBoundingClientRect();
                return {
                    x: ((event.clientX - rect.left) / this.container.clientWidth) * 2 - 1,
                    y: -((event.clientY - rect.top) / this.container.clientHeight) * 2 + 1
                };
            }

            getTouchPosition(event) {
                const rect = this.container.getBoundingClientRect();
                const touch = event.touches[0];
                return {
                    x: ((touch.clientX - rect.left) / this.container.clientWidth) * 2 - 1,
                    y: -((touch.clientY - rect.top) / this.container.clientHeight) * 2 + 1
                };
            }

            getGridPointFromMouse(event) {
                const mousePos = this.getMousePosition(event);
                this.mouse.set(mousePos.x, mousePos.y);
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObject(this.interactionPlane);
                
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    // è½¬æ¢å›ç½‘æ ¼åæ ‡
                    const gx = Math.floor((point.x + (GRID_SIZE * CELL_SIZE) / 2) / CELL_SIZE);
                    const gz = Math.floor((point.z + (GRID_SIZE * CELL_SIZE) / 2) / CELL_SIZE);
                    
                    if (gx >= 0 && gx < GRID_SIZE && gz >= 0 && gz < GRID_SIZE) {
                        return [gx, gz];
                    }
                }
                return null;
            }

            getGridPointFromTouch(event) {
                const touchPos = this.getTouchPosition(event);
                this.mouse.set(touchPos.x, touchPos.y);
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObject(this.interactionPlane);
                
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    // è½¬æ¢å›ç½‘æ ¼åæ ‡
                    const gx = Math.floor((point.x + (GRID_SIZE * CELL_SIZE) / 2) / CELL_SIZE);
                    const gz = Math.floor((point.z + (GRID_SIZE * CELL_SIZE) / 2) / CELL_SIZE);
                    
                    if (gx >= 0 && gx < GRID_SIZE && gz >= 0 && gz < GRID_SIZE) {
                        return [gx, gz];
                    }
                }
                return null;
            }

            onMouseDown(event) {
                // åªå“åº”å·¦é”® (button === 0)
                if (event.button !== 0) return; 
                
                const point = this.getGridPointFromMouse(event);
                if (!point) return;
                
                if (this.mode === 'DELETE') {
                    this.deleteWallAt(point);
                } else {
                    this.startDrawing(point);
                }
            }

            onMouseMove(event) {
                const point = this.getGridPointFromMouse(event);
                this.updateCurrentPoint(point);
            }

            onMouseUp() {
                this.stopDrawing();
            }

            onTouchStart(event) {
                // è§¦æ‘¸è®¾å¤‡é€šå¸¸å•æŒ‡æ˜¯å·¦é”®è¡Œä¸ºï¼ŒåŒæŒ‡æ˜¯æ¼«æ¸¸
                // è¿™é‡Œä¸åšå¤æ‚åŒºåˆ†ï¼Œå•æŒ‡ç›´æ¥ç”»
                const point = this.getGridPointFromTouch(event);
                if (!point) return;
                
                if (this.mode === 'DELETE') {
                    this.deleteWallAt(point);
                } else {
                    this.startDrawing(point);
                }
            }

            onTouchMove(event) {
                // event.preventDefault(); // ç§»é™¤ preventDefault ä»¥å…è®¸ OrbitControls æ¥ç®¡è§¦æ‘¸æ—‹è½¬ (å¦‚æœæ˜¯åŒæŒ‡)
                // OrbitControls é»˜è®¤å•æŒ‡è§¦æ‘¸æ˜¯æ—‹è½¬ã€‚è¿™å¯èƒ½å’Œç”»å¢™å†²çªã€‚
                // ä¼˜åŒ–ï¼šå¦‚æœæ˜¯å•æŒ‡ä¸”æ­£åœ¨ç»˜åˆ¶ï¼Œåˆ™ preventDefaultã€‚
                
                if (this.isDrawing) {
                    event.preventDefault();
                    const point = this.getGridPointFromTouch(event);
                    this.updateCurrentPoint(point);
                }
            }

            onTouchEnd() {
                this.stopDrawing();
            }

            startDrawing(point) {
                this.isDrawing = true;
                this.startPoint = point;
                this.currentPoint = point;
                // ç¦ç”¨æ§åˆ¶å™¨ï¼Œé¿å…ç”»å¢™æ—¶æ‹–æ‹½è§†è§’
                this.controls.enabled = false;
            }

            updateCurrentPoint(point) {
                if (!point) return;
                
                this.currentPoint = point;
                
                if (!this.isDrawing) {
                    // æ›´æ–°æ‚¬åœç½‘æ ¼ä½ç½®
                    this.updateHoverMesh(point);
                } else {
                    // æ›´æ–°é¢„è§ˆå¢™ä½“
                    this.updatePreviewWall();
                }
            }

            stopDrawing() {
                if (this.isDrawing && this.startPoint && this.currentPoint) {
                    // åªæœ‰é•¿åº¦å¤§äº0æ‰æ·»åŠ 
                    if (this.startPoint[0] !== this.currentPoint[0] || this.startPoint[1] !== this.currentPoint[1]) {
                        const newWall = {
                            id: Math.random().toString(36).substr(2, 9),
                            start: [...this.startPoint],
                            end: [...this.currentPoint]
                        };
                        this.walls.push(newWall);
                        this.updateScene();
                    }
                }
                
                this.isDrawing = false;
                this.startPoint = null;
                this.removePreviewWall();
                // é‡æ–°å¯ç”¨æ§åˆ¶å™¨
                this.controls.enabled = true;
            }

            deleteWallAt(point) {
                // ç®€å•çš„åˆ é™¤é€»è¾‘ï¼šåˆ é™¤é è¿‘ç‚¹å‡»ç‚¹çš„å¢™
                const tolerance = 1;
                const newWalls = this.walls.filter(wall => {
                    const [x1, z1] = wall.start;
                    const [x2, z2] = wall.end;
                    
                    // æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨å¢™çš„é™„è¿‘
                    // ä¸ºç®€åŒ–ï¼Œæ£€æŸ¥æ˜¯å¦ä¸èµ·ç‚¹æˆ–ç»ˆç‚¹é‡åˆ
                    if ((x1 === point[0] && z1 === point[1]) || (x2 === point[0] && z2 === point[1])) {
                        return false;
                    }
                    
                    // è®¡ç®—å¢™ä½“è¦†ç›–çš„ç½‘æ ¼
                    const minX = Math.min(x1, x2);
                    const maxX = Math.max(x1, x2);
                    const minZ = Math.min(z1, z2);
                    const maxZ = Math.max(z1, z2);
                    
                    // æ°´å¹³å¢™
                    if (z1 === z2) {
                        if (point[1] === z1 && point[0] >= minX && point[0] <= maxX) return false;
                    }
                    // å‚ç›´å¢™
                    else if (x1 === x2) {
                        if (point[0] === x1 && point[1] >= minZ && point[1] <= maxZ) return false;
                    }
                    
                    return true;
                });
                
                if (newWalls.length !== this.walls.length) {
                    this.walls = newWalls;
                    this.updateScene();
                }
            }

            updateHoverMesh(point) {
                if (!point) {
                    this.hoverMesh.visible = false;
                    return;
                }
                
                const wx = point[0] * CELL_SIZE - (GRID_SIZE * CELL_SIZE) / 2 + CELL_SIZE/2;
                const wz = point[1] * CELL_SIZE - (GRID_SIZE * CELL_SIZE) / 2 + CELL_SIZE/2;
                
                this.hoverMesh.position.set(wx, 0.02, wz);
                this.hoverMesh.visible = true;
            }

            updatePreviewWall() {
                if (!this.startPoint || !this.currentPoint) return;
                
                if (!this.previewWall) {
                    this.createPreviewWall();
                }
                
                const x1 = this.startPoint[0] * CELL_SIZE - (GRID_SIZE * CELL_SIZE) / 2 + CELL_SIZE/2;
                const z1 = this.startPoint[1] * CELL_SIZE - (GRID_SIZE * CELL_SIZE) / 2 + CELL_SIZE/2;
                const x2 = this.currentPoint[0] * CELL_SIZE - (GRID_SIZE * CELL_SIZE) / 2 + CELL_SIZE/2;
                const z2 = this.currentPoint[1] * CELL_SIZE - (GRID_SIZE * CELL_SIZE) / 2 + CELL_SIZE/2;
                
                const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(z2 - z1, 2)) + WALL_THICKNESS;
                const angle = Math.atan2(z2 - z1, x2 - x1);
                const midX = (x1 + x2) / 2;
                const midZ = (z1 + z2) / 2;
                
                this.previewWall.position.set(midX, WALL_HEIGHT / 2, midZ);
                this.previewWall.rotation.set(0, -angle, 0);
                this.previewWall.scale.set(length, 1, 1);
            }

            createPreviewWall() {
                const geometry = new THREE.BoxGeometry(1, WALL_HEIGHT, WALL_THICKNESS);
                const material = new THREE.MeshBasicMaterial({
                    color: COLORS.HIGHLIGHT,
                    opacity: 0.5,
                    transparent: true
                });
                this.previewWall = new THREE.Mesh(geometry, material);
                this.scene.add(this.previewWall);
            }

            removePreviewWall() {
                if (this.previewWall) {
                    this.scene.remove(this.previewWall);
                    this.previewWall.geometry.dispose();
                    this.previewWall.material.dispose();
                    this.previewWall = null;
                }
            }

            updateScene() {
                // ç§»é™¤æ—§çš„å¢™ä½“å’Œæˆ¿é—´
                this.removeAllWallMeshes();
                this.removeAllRoomMeshes();
                this.removeAllLabels();
                
                // åˆ†ææˆ¿é—´
                this.rooms = analyzeRooms(this.walls);
                
                // åˆ›å»ºæ–°çš„å¢™ä½“å’Œæˆ¿é—´
                this.createWallMeshes();
                this.createRoomMeshes();
                this.createLabels();
            }

            removeAllWallMeshes() {
                this.wallMeshes.forEach(mesh => {
                    this.scene.remove(mesh);
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                });
                this.wallMeshes = [];
            }

            removeAllRoomMeshes() {
                this.roomMeshes.forEach(mesh => {
                    this.scene.remove(mesh);
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                });
                this.roomMeshes = [];
            }

            removeAllLabels() {
                this.labelDivs.forEach(div => {
                    if (div.parentNode) div.parentNode.removeChild(div);
                });
                this.labelDivs = [];
            }

            createWallMeshes() {
                this.walls.forEach(wall => {
                    const x1 = wall.start[0] * CELL_SIZE - (GRID_SIZE * CELL_SIZE) / 2 + CELL_SIZE/2;
                    const z1 = wall.start[1] * CELL_SIZE - (GRID_SIZE * CELL_SIZE) / 2 + CELL_SIZE/2;
                    const x2 = wall.end[0] * CELL_SIZE - (GRID_SIZE * CELL_SIZE) / 2 + CELL_SIZE/2;
                    const z2 = wall.end[1] * CELL_SIZE - (GRID_SIZE * CELL_SIZE) / 2 + CELL_SIZE/2;
                    
                    const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(z2 - z1, 2)) + WALL_THICKNESS;
                    const angle = Math.atan2(z2 - z1, x2 - x1);
                    const midX = (x1 + x2) / 2;
                    const midZ = (z1 + z2) / 2;
                    
                    const geometry = new THREE.BoxGeometry(length, WALL_HEIGHT, WALL_THICKNESS);
                    const material = new THREE.MeshStandardMaterial({ color: COLORS.WALL });
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    mesh.position.set(midX, WALL_HEIGHT / 2, midZ);
                    mesh.rotation.set(0, -angle, 0);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    
                    this.scene.add(mesh);
                    this.wallMeshes.push(mesh);
                });
            }

            createRoomMeshes() {
                this.rooms.forEach(room => {
                    room.cells.forEach(([gx, gz], idx) => {
                        const wx = gx * CELL_SIZE - (GRID_SIZE * CELL_SIZE) / 2 + CELL_SIZE/2;
                        const wz = gz * CELL_SIZE - (GRID_SIZE * CELL_SIZE) / 2 + CELL_SIZE/2;
                        
                        const geometry = new THREE.PlaneGeometry(CELL_SIZE * 0.95, CELL_SIZE * 0.95);
                        const material = new THREE.MeshStandardMaterial({
                            color: room.color,
                            opacity: 0.8,
                            transparent: true,
                            side: THREE.DoubleSide
                        });
                        const mesh = new THREE.Mesh(geometry, material);
                        
                        mesh.position.set(wx, 0.05, wz);
                        mesh.rotation.x = -Math.PI / 2;
                        mesh.receiveShadow = true;
                        
                        this.scene.add(mesh);
                        this.roomMeshes.push(mesh);
                    });
                });
            }

            createLabels() {
                this.rooms.forEach(room => {
                    const div = document.createElement('div');
                    div.className = 'html-label';
                    div.innerHTML = `
                        <div class="label-title">${room.label}</div>
                        <div class="label-area">${room.area * 2}mÂ²</div>
                    `;
                    document.body.appendChild(div);
                    this.labelDivs.push(div);
                });
            }

            updateLabels() {
                this.rooms.forEach((room, index) => {
                    const div = this.labelDivs[index];
                    if (!div) return;
                    
                    const vector = new THREE.Vector3(
                        room.center[0],
                        WALL_HEIGHT + 0.5,
                        room.center[2]
                    );
                    
                    vector.project(this.camera);
                    
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
                    
                    div.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                    
                    if (Math.abs(vector.z) > 1) {
                         div.style.display = 'none';
                    } else {
                         div.style.display = 'block';
                    }
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.controls.update();
                this.updateLabels();
                this.renderer.render(this.scene, this.camera);
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('scene-container');
            const bimScene = new BIMScene(container);
        });
    </script>
</body>
</html>
