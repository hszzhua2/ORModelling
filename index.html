<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIM è‡ªåŠ¨åŒ–é€»è¾‘æ¼”ç¤º (High Precision)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        dark: '#0f172a', // æ›´æ·±çš„èƒŒæ™¯
                    }
                }
            }
        }
    </script>
    
    <!-- å¼•å…¥ Import Map ä»¥è§£å†³æ¨¡å—ä¾èµ–é—®é¢˜ -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/"
            }
        }
    </script>

    <style type="text/tailwindcss">
        @layer utilities {
            .backdrop-blur-md { backdrop-filter: blur(12px); }
            .font-sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
        }
    </style>
    <style>
        body {
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            user-select: none;
            background-color: #0f172a;
        }
        .html-label {
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.9);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px);
            pointer-events: none;
            text-align: center;
            white-space: nowrap;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            top: 0; left: 0;
            display: none;
            z-index: 10;
            transition: opacity 0.2s;
        }
        .mode-btn {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .mode-btn.active {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(56, 178, 172, 0.5);
            border-color: rgba(56, 178, 172, 0.8);
            background: rgba(56, 178, 172, 0.2);
            color: #fff;
        }
        /* ç®€å•çš„åŠ è½½åŠ¨ç”» */
        .loading {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: #0f172a; z-index: 100;
            display: flex; justify-content: center; align-items: center;
            color: white; font-size: 1.5rem;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body class="w-full h-screen text-gray-200 font-sans">
    <div id="loading" class="loading">æ­£åœ¨åˆå§‹åŒ–é«˜ç²¾åº¦ç½‘æ ¼...</div>

    <!-- UI å±‚ -->
    <div class="absolute inset-0 pointer-events-none z-10 flex flex-col justify-between p-6">
        
        <!-- é¡¶éƒ¨ä¿¡æ¯ -->
        <div class="flex justify-between items-start">
            <div>
                <h1 class="text-3xl font-light tracking-tight text-white mb-1">
                    <span class="font-bold text-teal-400">Liquid</span>BIM 
                    <span class="text-xs align-top opacity-50 ml-1">v2.0</span>
                </h1>
                <p class="text-gray-400 text-sm max-w-md">
                    é«˜ç²¾åº¦è‡ªåŠ¨åŒ–ç©ºé—´è§„åˆ’ç³»ç»Ÿ <br/>
                    <span class="text-xs opacity-60">Grid Resolution: 0.2m | Voxel Engine Active</span>
                </p>
            </div>
            
            <!-- è§„åˆ™å›¾ä¾‹ -->
            <div class="bg-slate-800/50 p-4 rounded-xl backdrop-blur-md border border-white/10 shadow-2xl pointer-events-auto">
                <h3 class="text-xs font-bold uppercase tracking-widest text-gray-500 mb-3">Zone Logic</h3>
                <div class="space-y-2 text-xs">
                    <div class="flex items-center gap-3">
                        <div class="w-2 h-2 rounded-full shadow-[0_0_8px_rgba(45,212,191,0.8)] bg-teal-400"></div>
                        <span class="text-gray-300">æ‰‹æœ¯å®¤ (Area > 35mÂ²)</span>
                    </div>
                    <div class="flex items-center gap-3">
                        <div class="w-2 h-2 rounded-full shadow-[0_0_8px_rgba(96,165,250,0.8)] bg-blue-400"></div>
                        <span class="text-gray-300">è¾…åŠ©ç”¨æˆ¿ (Area < 15mÂ²)</span>
                    </div>
                    <div class="flex items-center gap-3">
                        <div class="w-2 h-2 rounded-full shadow-[0_0_8px_rgba(250,204,21,0.8)] bg-yellow-400"></div>
                        <span class="text-gray-300">äº¤é€šç©ºé—´ (Ratio > 3:1)</span>
                    </div>
                    <div class="flex items-center gap-3">
                        <div class="w-2 h-2 rounded-full shadow-[0_0_8px_rgba(251,146,60,0.8)] bg-orange-400"></div>
                        <span class="text-gray-300">é€šç”¨å­˜å‚¨ (Default)</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- åº•éƒ¨å·¥å…·æ  -->
        <div class="flex flex-col items-center gap-4 pointer-events-auto">
            <!-- æ¨¡å¼åˆ‡æ¢å™¨ -->
            <div class="flex items-center gap-2 bg-slate-900/80 p-1.5 rounded-2xl border border-white/10 backdrop-blur-xl shadow-2xl">
                <button onclick="app.setMode('SELECT')" id="btn-select" class="mode-btn px-6 py-3 rounded-xl flex items-center gap-2 text-sm font-medium text-gray-400 hover:text-white border border-transparent">
                    <i class="fa fa-mouse-pointer"></i> 
                    <span>é€‰æ‹© (1)</span>
                </button>
                <button onclick="app.setMode('DRAW')" id="btn-draw" class="mode-btn px-6 py-3 rounded-xl flex items-center gap-2 text-sm font-medium text-gray-400 hover:text-white border border-transparent">
                    <i class="fa fa-pencil"></i>
                    <span>ç»˜åˆ¶ (2)</span>
                </button>
                <button onclick="app.setMode('DELETE')" id="btn-delete" class="mode-btn px-6 py-3 rounded-xl flex items-center gap-2 text-sm font-medium text-gray-400 hover:text-white border border-transparent">
                    <i class="fa fa-eraser"></i>
                    <span>åˆ é™¤ (3)</span>
                </button>
            </div>
            
            <button onclick="app.clearAll()" class="text-xs text-red-400/70 hover:text-red-400 transition-colors py-2">
                <i class="fa fa-trash-o mr-1"></i> æ¸…ç©ºæ‰€æœ‰æ•°æ®
            </button>
        </div>
        
        <!-- æ“ä½œæç¤º -->
        <div class="absolute bottom-6 right-6 text-right pointer-events-none opacity-50">
            <div class="text-xs space-y-1">
                <p>ğŸ–±ï¸ å·¦é”®: æ‰§è¡Œæ¨¡å¼æ“ä½œ</p>
                <p>ğŸ–±ï¸ å³é”®: æ—‹è½¬è§†è§’</p>
                <p>ğŸ–±ï¸ ä¸­é”®: å¹³ç§»ç”»å¸ƒ</p>
            </div>
        </div>
    </div>

    <div id="scene-container" class="w-full h-full"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- å…¨å±€å¸¸é‡ (High Precision) ---
        const GRID_SIZE = 150;      // 30ç±³èŒƒå›´ (150 * 0.2)
        const CELL_SIZE = 0.2;      // 0.2ç±³ç²¾åº¦
        const WALL_HEIGHT = 2.8;    // 2.8ç±³å±‚é«˜
        const WALL_THICKNESS = 0.2; // 200mmå¢™åš
        const ROOM_HEIGHT = 2.2;    // æˆ¿é—´ä½“å—é«˜åº¦ (ç•¥ä½äºå¢™)

        // é¢œè‰²é…ç½® (Glass Style)
        const PALETTE = {
            WALL: 0xffffff, // ç™½ç£¨ç ‚
            OR: 0x2dd4bf,   // Teal
            SCRUB: 0x60a5fa, // Blue
            CORRIDOR: 0xfacc15, // Yellow
            STORAGE: 0xfb923c, // Orange
            UNKNOWN: 0x94a3b8, // Slate
            HIGHLIGHT: 0xf43f5e // Rose
        };

        // --- æ ¸å¿ƒé€»è¾‘ç±» ---
        class BIMManager {
            constructor() {
                this.walls = [];
                this.rooms = [];
                this.container = document.getElementById('scene-container');
                this.mode = 'DRAW'; // SELECT, DRAW, DELETE
                
                this.initThree();
                this.initInteraction();
                this.initPreset();

                // ç§»é™¤ loading
                document.getElementById('loading').style.opacity = 0;
                setTimeout(() => document.getElementById('loading').remove(), 500);

                this.updateUI();
                
                // æš´éœ²ç»™å…¨å±€ä»¥ä¾¿ HTML æŒ‰é’®è°ƒç”¨
                window.app = this;
            }

            initThree() {
                // åœºæ™¯
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color('#0f172a');
                // æ·»åŠ ä¸€äº›è¿·é›¾å¢åŠ æ·±é‚ƒæ„Ÿ
                this.scene.fog = new THREE.FogExp2(0x0f172a, 0.02);

                // ç›¸æœº
                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(15, 25, 25);

                // æ¸²æŸ“å™¨ (å¼€å¯ç‰©ç†å…‰ç…§è®¡ç®—)
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                this.container.appendChild(this.renderer.domElement);

                // æ§åˆ¶å™¨
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.maxPolarAngle = Math.PI / 2.1; // ä¸å…è®¸çœ‹ç©¿åœ°æ¿
                this.controls.minDistance = 5;
                this.controls.maxDistance = 60;
                // æŒ‰é”®æ˜ å°„
                this.controls.mouseButtons = {
                    LEFT: null, // å·¦é”®ç•™ç»™æ“ä½œ
                    MIDDLE: THREE.MOUSE.PAN,
                    RIGHT: THREE.MOUSE.ROTATE
                };

                // ç¯å…‰ç³»ç»Ÿ (ä¸ºäº† Liquid Glass æ•ˆæœï¼Œç¯å…‰è‡³å…³é‡è¦)
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
                this.scene.add(ambientLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
                dirLight.position.set(10, 40, 20);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                this.scene.add(dirLight);

                // è¡¥å…‰ï¼Œå¢åŠ ç»ç’ƒé€šé€æ„Ÿ
                const fillLight = new THREE.PointLight(0x88ccff, 0.8);
                fillLight.position.set(-10, 10, -10);
                this.scene.add(fillLight);

                // è¾…åŠ©å¹³é¢
                this.createHelpers();

                // äº¤äº’å°„çº¿
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                // æ¸²æŸ“å¾ªç¯
                this.animate = this.animate.bind(this);
                this.animate();

                // çª—å£è°ƒæ•´
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            createHelpers() {
                // åœ°é¢ç½‘æ ¼ (æ›´ç»†è…»)
                const grid = new THREE.GridHelper(30, 30, 0x334155, 0x1e293b);
                this.scene.add(grid);

                // äº¤äº’å¹³é¢ (ä¸å¯è§)
                const planeGeo = new THREE.PlaneGeometry(100, 100);
                const planeMat = new THREE.MeshBasicMaterial({ visible: false });
                this.interactionPlane = new THREE.Mesh(planeGeo, planeMat);
                this.interactionPlane.rotation.x = -Math.PI / 2;
                this.scene.add(this.interactionPlane);

                // æ‚¬åœå…‰æ ‡ (3D Box)
                const cursorGeo = new THREE.BoxGeometry(CELL_SIZE, CELL_SIZE, CELL_SIZE);
                const cursorMat = new THREE.MeshBasicMaterial({ 
                    color: PALETTE.HIGHLIGHT, 
                    transparent: true, 
                    opacity: 0.5,
                    wireframe: true
                });
                this.cursor = new THREE.Mesh(cursorGeo, cursorMat);
                this.scene.add(this.cursor);
                
                // é¢„è§ˆå¢™ä½“
                const previewGeo = new THREE.BoxGeometry(1, WALL_HEIGHT, WALL_THICKNESS);
                const previewMat = new THREE.MeshPhysicalMaterial({
                    color: PALETTE.HIGHLIGHT,
                    transmission: 0.5,
                    opacity: 1,
                    roughness: 0.1,
                    transparent: true
                });
                this.previewWall = new THREE.Mesh(previewGeo, previewMat);
                this.previewWall.visible = false;
                this.scene.add(this.previewWall);

                // æˆ¿é—´ InstancedMesh å®¹å™¨ (ç”¨äºé«˜æ€§èƒ½æ¸²æŸ“å¤§é‡ä½“ç´ )
                // å®é™…ä¸Šï¼Œä¸ºäº†ç»ç’ƒæ•ˆæœï¼Œæˆ‘ä»¬éœ€è¦åˆå¹¶å‡ ä½•ä½“æˆ–è€…ä½¿ç”¨ Instance
                // ä¸ºäº†æ¼”ç¤ºæ•ˆæœå’Œç®€å•èµ·è§ï¼Œæˆ‘ä»¬å¯¹æ¯ç§ç±»å‹çš„æˆ¿é—´ä½¿ç”¨ä¸€ä¸ª InstancedMesh
                this.roomInstancedMeshes = {};
            }

            initInteraction() {
                // é”®ç›˜å¿«æ·é”®
                window.addEventListener('keydown', (e) => {
                    if (e.key === '1') this.setMode('SELECT');
                    if (e.key === '2') this.setMode('DRAW');
                    if (e.key === '3') this.setMode('DELETE');
                    if (e.key === 'Escape') this.cancelAction();
                });

                const canvas = this.renderer.domElement;
                
                // ç»Ÿä¸€å¤„ç†åæ ‡è½¬æ¢
                const updateMouse = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                    this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                };

                // é¼ æ ‡äº‹ä»¶
                canvas.addEventListener('mousemove', (e) => {
                    updateMouse(e);
                    this.onHover();
                });

                canvas.addEventListener('mousedown', (e) => {
                    if(e.button !== 0) return; // ä»…å·¦é”®
                    updateMouse(e);
                    this.onMouseDown();
                });

                canvas.addEventListener('mouseup', () => {
                    this.onMouseUp();
                });

                // ç¦ç”¨å³é”®èœå•
                canvas.addEventListener('contextmenu', e => e.preventDefault());
            }

            setMode(mode) {
                this.mode = mode;
                this.cancelAction(); // åˆ‡æ¢æ¨¡å¼æ—¶é‡ç½®çŠ¶æ€
                this.updateUI();
            }
            
            cancelAction() {
                this.isDrawing = false;
                this.startPoint = null;
                this.previewWall.visible = false;
                if(this.mode === 'SELECT') this.highlightRoom(null);
            }

            updateUI() {
                document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
                if(this.mode === 'SELECT') document.getElementById('btn-select').classList.add('active');
                if(this.mode === 'DRAW') document.getElementById('btn-draw').classList.add('active');
                if(this.mode === 'DELETE') document.getElementById('btn-delete').classList.add('active');
                
                document.body.style.cursor = this.mode === 'DRAW' ? 'crosshair' : (this.mode === 'DELETE' ? 'not-allowed' : 'default');
            }

            // --- å‡ ä½•ä¸é€»è¾‘è½¬æ¢ ---

            getGridPoint() {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObject(this.interactionPlane);
                if (intersects.length > 0) {
                    const p = intersects[0].point;
                    // è½¬æ¢åˆ°ç½‘æ ¼åæ ‡ (0..GRID_SIZE)
                    const gx = Math.round((p.x + (GRID_SIZE * CELL_SIZE) / 2) / CELL_SIZE);
                    const gz = Math.round((p.z + (GRID_SIZE * CELL_SIZE) / 2) / CELL_SIZE);
                    
                    if (gx >= 0 && gx < GRID_SIZE && gz >= 0 && gz < GRID_SIZE) {
                        return { gx, gz, wx: p.x, wz: p.z }; // Grid X, Grid Z, World X, World Z
                    }
                }
                return null;
            }

            // --- äº¤äº’é€»è¾‘ ---

            onHover() {
                const hit = this.getGridPoint();
                if (!hit) {
                    this.cursor.visible = false;
                    return;
                }

                // å¯¹é½åˆ°ç½‘æ ¼ä¸­å¿ƒ
                const snapX = (hit.gx * CELL_SIZE) - (GRID_SIZE * CELL_SIZE)/2;
                const snapZ = (hit.gz * CELL_SIZE) - (GRID_SIZE * CELL_SIZE)/2;
                
                this.cursor.position.set(snapX, CELL_SIZE/2, snapZ);
                this.cursor.visible = true;

                if (this.mode === 'DRAW') {
                    this.cursor.material.color.setHex(PALETTE.HIGHLIGHT);
                    if (this.isDrawing && this.startPoint) {
                        this.updatePreview(this.startPoint, {gx: hit.gx, gz: hit.gz});
                    }
                } else if (this.mode === 'DELETE') {
                    this.cursor.material.color.setHex(0xff0000);
                    // å¯ä»¥åœ¨è¿™é‡Œåšåˆ é™¤é«˜äº®é¢„è§ˆ
                } else if (this.mode === 'SELECT') {
                    this.cursor.material.color.setHex(0x38b2ac);
                    // æŸ¥æ‰¾å½“å‰é¼ æ ‡ä¸‹çš„æˆ¿é—´
                    const room = this.findRoomAt(hit.gx, hit.gz);
                    this.highlightRoom(room);
                }
            }

            onMouseDown() {
                const hit = this.getGridPoint();
                if (!hit) return;

                if (this.mode === 'DRAW') {
                    this.isDrawing = true;
                    this.startPoint = { gx: hit.gx, gz: hit.gz };
                } else if (this.mode === 'DELETE') {
                    this.deleteWall(hit);
                }
            }

            onMouseUp() {
                if (this.mode === 'DRAW' && this.isDrawing) {
                    const hit = this.getGridPoint();
                    if (hit && this.startPoint) {
                        // æ·»åŠ å¢™ä½“
                        if (hit.gx !== this.startPoint.gx || hit.gz !== this.startPoint.gz) {
                            this.addWall(this.startPoint, { gx: hit.gx, gz: hit.gz });
                        }
                    }
                    this.isDrawing = false;
                    this.startPoint = null;
                    this.previewWall.visible = false;
                }
            }

            updatePreview(start, end) {
                // è®¡ç®—ä¸­å¿ƒç‚¹ã€é•¿åº¦ã€è§’åº¦
                const p1 = this.gridToWorld(start.gx, start.gz);
                const p2 = this.gridToWorld(end.gx, end.gz);
                
                const midX = (p1.x + p2.x) / 2;
                const midZ = (p1.z + p2.z) / 2;
                const len = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2)) + WALL_THICKNESS;
                const angle = Math.atan2(p2.z - p1.z, p2.x - p1.x);

                this.previewWall.position.set(midX, WALL_HEIGHT/2, midZ);
                this.previewWall.rotation.y = -angle;
                this.previewWall.scale.x = len;
                this.previewWall.visible = true;
            }

            gridToWorld(gx, gz) {
                return {
                    x: gx * CELL_SIZE - (GRID_SIZE * CELL_SIZE)/2,
                    z: gz * CELL_SIZE - (GRID_SIZE * CELL_SIZE)/2
                };
            }

            // --- ä¸šåŠ¡é€»è¾‘ ---

            addWall(start, end) {
                const id = Math.random().toString(36).substr(2, 9);
                this.walls.push({ id, start: [start.gx, start.gz], end: [end.gx, end.gz] });
                this.rebuildModel();
            }

            deleteWall(hit) {
                // ç®€å•çš„ç¢°æ’æ£€æµ‹ï¼šç‚¹åˆ°çº¿æ®µè·ç¦»
                // ä¸ºäº†æ¼”ç¤ºç®€ä¾¿ï¼Œæˆ‘ä»¬ç”¨ Grid ç¢°æ’
                const tolerance = 2; // å…è®¸è¯¯å·®èŒƒå›´
                const initialCount = this.walls.length;

                this.walls = this.walls.filter(w => {
                    // æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨çº¿æ®µåŒ…å›´ç›’é™„è¿‘
                    const minX = Math.min(w.start[0], w.end[0]) - tolerance;
                    const maxX = Math.max(w.start[0], w.end[0]) + tolerance;
                    const minZ = Math.min(w.start[1], w.end[1]) - tolerance;
                    const maxZ = Math.max(w.start[1], w.end[1]) + tolerance;

                    if (hit.gx >= minX && hit.gx <= maxX && hit.gz >= minZ && hit.gz <= maxZ) {
                        // è¿›ä¸€æ­¥æ£€æŸ¥ç‚¹åˆ°ç›´çº¿çš„è·ç¦»
                        // è¿™é‡Œç®€åŒ–ä¸ºï¼šå¦‚æœåœ¨åŒ…å›´ç›’å†…å°±åˆ é™¤ï¼Œä½“éªŒæ¯”è¾ƒçˆ½å¿«
                        return false;
                    }
                    return true;
                });

                if (this.walls.length !== initialCount) {
                    this.rebuildModel();
                }
            }

            clearAll() {
                this.walls = [];
                this.rebuildModel();
            }

            // --- æ ¸å¿ƒç®—æ³• (High Precision) ---
            
            rebuildModel() {
                // 1. æ¸…ç†åœºæ™¯å¢™ä½“
                if (this.wallMeshes) {
                    this.wallMeshes.forEach(m => {
                        this.scene.remove(m);
                        m.geometry.dispose();
                    });
                }
                this.wallMeshes = [];

                // 2. é‡å»ºå¢™ä½“ (Liquid Glass Style: Frosted Glass)
                const wallMat = new THREE.MeshPhysicalMaterial({
                    color: 0xffffff,
                    metalness: 0.1,
                    roughness: 0.2, // ç£¨ç ‚æ„Ÿ
                    transmission: 0.6, // åŠé€æ˜
                    thickness: 1.0,
                    clearcoat: 1.0,
                    side: THREE.DoubleSide
                });

                this.walls.forEach(w => {
                    const p1 = this.gridToWorld(w.start[0], w.start[1]);
                    const p2 = this.gridToWorld(w.end[0], w.end[1]);
                    
                    const len = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2)) + WALL_THICKNESS;
                    const angle = Math.atan2(p2.z - p1.z, p2.x - p1.x);
                    
                    const geo = new THREE.BoxGeometry(len, WALL_HEIGHT, WALL_THICKNESS);
                    const mesh = new THREE.Mesh(geo, wallMat);
                    mesh.position.set((p1.x + p2.x)/2, WALL_HEIGHT/2, (p1.z + p2.z)/2);
                    mesh.rotation.y = -angle;
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    this.scene.add(mesh);
                    this.wallMeshes.push(mesh);
                });

                // 3. è®¡ç®—æˆ¿é—´
                this.analyzeRooms();
            }

            analyzeRooms() {
                // åˆå§‹åŒ– Grid
                // 0: Empty, 1: Wall, 2+: Room ID
                const grid = new Int32Array(GRID_SIZE * GRID_SIZE).fill(0);

                // æ …æ ¼åŒ–å¢™ä½“ (Bresenham line algorithm)
                this.walls.forEach(w => {
                    let x0 = w.start[0], y0 = w.start[1];
                    let x1 = w.end[0], y1 = w.end[1];
                    let dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
                    let sx = (x0 < x1) ? 1 : -1, sy = (y0 < y1) ? 1 : -1;
                    let err = dx - dy;

                    while (true) {
                        if (x0 >= 0 && x0 < GRID_SIZE && y0 >= 0 && y0 < GRID_SIZE) {
                            grid[y0 * GRID_SIZE + x0] = 1; // Wall
                        }
                        if (x0 === x1 && y0 === y1) break;
                        let e2 = 2 * err;
                        if (e2 > -dy) { err -= dy; x0 += sx; }
                        if (e2 < dx) { err += dx; y0 += sy; }
                    }
                });

                // æ³›æ´ªç®—æ³•
                this.rooms = [];
                const visited = new Uint8Array(GRID_SIZE * GRID_SIZE).fill(0);
                
                for (let z = 0; z < GRID_SIZE; z++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const idx = z * GRID_SIZE + x;
                        if (grid[idx] === 0 && visited[idx] === 0) {
                            // æ–°åŒºåŸŸ
                            const cells = [];
                            const queue = [idx];
                            visited[idx] = 1;
                            let isClosed = true;

                            // BFS
                            let ptr = 0;
                            while(ptr < queue.length) {
                                const curr = queue[ptr++];
                                const cx = curr % GRID_SIZE;
                                const cz = Math.floor(curr / GRID_SIZE);
                                cells.push({x: cx, z: cz});

                                // è¾¹ç•Œæ£€æµ‹
                                if (cx === 0 || cx === GRID_SIZE-1 || cz === 0 || cz === GRID_SIZE-1) {
                                    isClosed = false;
                                }

                                // é‚»å±…
                                const neighbors = [
                                    {nx: cx+1, nz: cz}, {nx: cx-1, nz: cz},
                                    {nx: cx, nz: cz+1}, {nx: cx, nz: cz-1}
                                ];

                                for(let n of neighbors) {
                                    if(n.nx >=0 && n.nx < GRID_SIZE && n.nz >=0 && n.nz < GRID_SIZE) {
                                        const nIdx = n.nz * GRID_SIZE + n.nx;
                                        if (grid[nIdx] !== 1 && visited[nIdx] === 0) {
                                            visited[nIdx] = 1;
                                            queue.push(nIdx);
                                        }
                                    }
                                }
                            }

                            if (isClosed && cells.length > 0) {
                                this.classifyAndAddRoom(cells);
                            }
                        }
                    }
                }

                this.visualizeRooms();
            }

            classifyAndAddRoom(cells) {
                // è®¡ç®—ç‰©ç†å±æ€§
                const area = cells.length * (CELL_SIZE * CELL_SIZE); // mÂ²
                
                // è®¡ç®— AABB
                let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
                let sumX = 0, sumZ = 0;
                cells.forEach(c => {
                    minX = Math.min(minX, c.x);
                    maxX = Math.max(maxX, c.x);
                    minZ = Math.min(minZ, c.z);
                    maxZ = Math.max(maxZ, c.z);
                    sumX += c.x;
                    sumZ += c.z;
                });
                
                // é•¿å®½æ¯” (åŸºäºåŒ…å›´ç›’è¿‘ä¼¼)
                const width = (maxX - minX + 1) * CELL_SIZE;
                const depth = (maxZ - minZ + 1) * CELL_SIZE;
                const ratio = Math.max(width, depth) / Math.min(width, depth);

                // --- è§„åˆ™å¼•æ“ v2.0 ---
                let type = 'STORAGE';
                let label = 'é€šç”¨å­˜å‚¨';
                let color = PALETTE.STORAGE;

                if (area > 35 && ratio < 2.0) {
                    type = 'OR';
                    label = 'æ‰‹æœ¯å®¤';
                    color = PALETTE.OR;
                } else if (ratio > 3.0) {
                    type = 'CORRIDOR';
                    label = 'èµ°å»Š';
                    color = PALETTE.CORRIDOR;
                } else if (area < 15) {
                    type = 'SCRUB';
                    label = 'è¾…åŠ©ç”¨æˆ¿';
                    color = PALETTE.SCRUB;
                }

                // ä¸­å¿ƒç‚¹
                const cx = (sumX / cells.length);
                const cz = (sumZ / cells.length);
                const centerWorld = this.gridToWorld(cx, cz);

                this.rooms.push({
                    id: this.rooms.length,
                    cells,
                    area,
                    type,
                    label,
                    color,
                    center: centerWorld
                });
            }

            visualizeRooms() {
                // æ¸…ç†æ—§çš„ Mesh
                Object.values(this.roomInstancedMeshes).forEach(mesh => {
                    this.scene.remove(mesh);
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                    mesh.dispose(); 
                });
                this.roomInstancedMeshes = {};
                this.removeAllLabels();

                // ä½¿ç”¨ InstancedMesh æ¸²æŸ“æµ·é‡ä½“ç´  (Grid Size 150*150 å¯èƒ½æœ‰ 20000+ ä¸ªæ–¹å—)
                // æŒ‰é¢œè‰²/ç±»å‹åˆ†ç»„
                const groups = {};
                this.rooms.forEach(room => {
                    if (!groups[room.color]) groups[room.color] = [];
                    groups[room.color].push(...room.cells);
                });

                // åŸºç¡€å‡ ä½•ä½“ (Box Voxel)
                const geometry = new THREE.BoxGeometry(CELL_SIZE * 0.95, ROOM_HEIGHT, CELL_SIZE * 0.95);
                
                Object.keys(groups).forEach(color => {
                    const cells = groups[color];
                    const count = cells.length;
                    
                    if (count === 0) return;

                    // Liquid Glass æè´¨
                    const material = new THREE.MeshPhysicalMaterial({
                        color: parseInt(color),
                        metalness: 0,
                        roughness: 0.1,
                        transmission: 0.85, // é«˜é€
                        thickness: 1.5,
                        clearcoat: 1.0,
                        transparent: true,
                        opacity: 1.0
                    });

                    const mesh = new THREE.InstancedMesh(geometry, material, count);
                    const matrix = new THREE.Matrix4();
                    
                    cells.forEach((cell, i) => {
                        const wPos = this.gridToWorld(cell.x, cell.z);
                        // ç¨å¾®éšæœºä¸€ç‚¹é«˜åº¦å¢åŠ æ¶²ä½“æ„Ÿï¼Ÿæˆ–è€…å¹³æ•´
                        matrix.setPosition(wPos.x, ROOM_HEIGHT/2, wPos.z);
                        mesh.setMatrixAt(i, matrix);
                    });

                    mesh.receiveShadow = true;
                    // InstancedMesh ä¸éœ€è¦ castShadow (å¤ªé‡)
                    
                    this.scene.add(mesh);
                    this.roomInstancedMeshes[color] = mesh;
                });

                this.createLabels();
            }

            // --- æ ‡ç­¾ç³»ç»Ÿ ---
            
            createLabels() {
                this.labels = [];
                this.rooms.forEach(room => {
                    const div = document.createElement('div');
                    div.className = 'html-label';
                    div.innerHTML = `
                        <div class="label-title">${room.label}</div>
                        <div class="label-area">${room.area.toFixed(1)} mÂ²</div>
                    `;
                    document.body.appendChild(div);
                    this.labels.push({ div, pos: room.center });
                });
            }

            removeAllLabels() {
                if (this.labels) {
                    this.labels.forEach(l => l.div.remove());
                }
                this.labels = [];
            }

            updateLabels() {
                if (!this.labels) return;
                
                this.labels.forEach(item => {
                    // 3D -> 2D
                    const v = new THREE.Vector3(item.pos.x, WALL_HEIGHT + 1, item.pos.z);
                    v.project(this.camera);

                    const x = (v.x * .5 + .5) * this.container.clientWidth;
                    const y = (-(v.y * .5) + .5) * this.container.clientHeight;

                    if (Math.abs(v.z) < 1) {
                         item.div.style.display = 'block';
                         item.div.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                    } else {
                         item.div.style.display = 'none';
                    }
                });
            }

            // --- è¾…åŠ©åŠŸèƒ½ ---
            
            findRoomAt(gx, gz) {
                // ç®€å•éå† (å› ä¸ºæˆ¿é—´ä¸å¤š)
                for (let r of this.rooms) {
                    // æ£€æŸ¥ cells
                    // ä¼˜åŒ–ï¼šå¯ä»¥ç”¨ Set æˆ– Map åŠ é€Ÿï¼Œä½†åœ¨æ¼”ç¤ºè§„æ¨¡ä¸‹éå†æ•°ç»„è¶³å¤Ÿå¿«
                    if (r.cells.some(c => c.x === gx && c.z === gz)) {
                        return r;
                    }
                }
                return null;
            }

            highlightRoom(room) {
                // é«˜äº®é€»è¾‘: 
                // ç”±äºä½¿ç”¨äº† InstancedMeshï¼Œè¿™é‡Œç®€å•å¤„ç†ï¼šæ˜¾ç¤º Label è¯¦ç»†ä¿¡æ¯ï¼Œæˆ–è€…æ”¹å˜ Cursor é¢œè‰²
                // çœŸæ­£çš„ InstancedMesh å±€éƒ¨å˜è‰²æ¯”è¾ƒå¤æ‚ (setColorAt + needsUpdate)ï¼Œæ¼”ç¤ºä¸­æˆ‘ä»¬é€šè¿‡ UI åé¦ˆ
                if (room) {
                    // æ‰¾åˆ°å¯¹åº”çš„ Label è®¾ä¸ºé«˜äº®æ ·å¼
                    this.labels.forEach(l => {
                        if (l.pos === room.center) {
                            l.div.style.background = 'rgba(56, 178, 172, 0.8)';
                            l.div.style.zIndex = 20;
                        } else {
                            l.div.style.background = 'rgba(255, 255, 255, 0.1)';
                            l.div.style.zIndex = 10;
                        }
                    });
                } else {
                    // Reset
                    this.labels.forEach(l => l.div.style.background = 'rgba(255, 255, 255, 0.1)');
                }
            }

            initPreset() {
                // é¢„è®¾å¢™ä½“ (åæ ‡éœ€é€‚é… 150x150 ç½‘æ ¼ï¼Œ30mèŒƒå›´)
                // 1.5m å•å…ƒæ ¼æ—¶ [2,2] -> 3m. 
                // 0.2m å•å…ƒæ ¼æ—¶ï¼Œ3m -> 15 units.
                // è½¬æ¢æ—§æ•°æ®æ¯”ä¾‹ï¼š 150(grid) / 20(old_grid) = 7.5 å€
                const scale = 7.5;
                const offset = 0; 
                
                const walls = [
                     { start: [2, 2], end: [2, 12] },
                     { start: [2, 12], end: [15, 12] },
                     { start: [15, 12], end: [15, 2] },
                     { start: [15, 2], end: [2, 2] },
                     { start: [6, 2], end: [6, 12] }
                ];
                
                walls.forEach(w => {
                    this.addWall(
                        {gx: Math.round(w.start[0] * scale), gz: Math.round(w.start[1] * scale)},
                        {gx: Math.round(w.end[0] * scale), gz: Math.round(w.end[1] * scale)}
                    );
                });
            }

            animate() {
                requestAnimationFrame(this.animate);
                this.controls.update();
                this.updateLabels();
                this.renderer.render(this.scene, this.camera);
            }
        }

        // å¯åŠ¨
        window.onload = () => {
            new BIMManager();
        };

    </script>
</body>
</html>
